/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { GeneratedClient } from "../generatedClient";
import {
  PoolUsageMetrics,
  PoolListUsageMetricsNextOptionalParams,
  PoolListUsageMetricsOptionalParams,
  CloudPool,
  PoolListNextOptionalParams,
  PoolListOptionalParams,
  PoolListUsageMetricsResponse,
  PoolGetAllLifetimeStatisticsOptionalParams,
  PoolGetAllLifetimeStatisticsResponse,
  PoolAddParameter,
  PoolAddOptionalParams,
  PoolAddResponse,
  PoolListResponse,
  PoolDeleteOptionalParams,
  PoolDeleteResponse,
  PoolExistsOptionalParams,
  PoolExistsResponse,
  PoolGetOptionalParams,
  PoolGetResponse,
  PoolPatchParameter,
  PoolPatchOptionalParams,
  PoolPatchResponse,
  PoolDisableAutoScaleOptionalParams,
  PoolDisableAutoScaleResponse,
  PoolEnableAutoScaleParameter,
  PoolEnableAutoScaleOptionalParams,
  PoolEnableAutoScaleResponse,
  PoolEvaluateAutoScaleParameter,
  PoolEvaluateAutoScaleOptionalParams,
  PoolEvaluateAutoScaleResponse,
  PoolResizeParameter,
  PoolResizeOptionalParams,
  PoolResizeResponse,
  PoolStopResizeOptionalParams,
  PoolStopResizeResponse,
  PoolUpdatePropertiesParameter,
  PoolUpdatePropertiesOptionalParams,
  PoolUpdatePropertiesResponse,
  NodeRemoveParameter,
  PoolRemoveNodesOptionalParams,
  PoolRemoveNodesResponse,
  PoolListUsageMetricsNextResponse,
  PoolListNextResponse
} from "../models";

/** Class representing a Pool. */
export class Pool {
  private readonly client: GeneratedClient;

  /**
   * Initialize a new instance of the class Pool class.
   * @param client Reference to the service client
   */
  constructor(client: GeneratedClient) {
    this.client = client;
  }

  /**
   * If you do not specify a $filter clause including a poolId, the response includes all Pools that
   * existed in the Account in the time range of the returned aggregation intervals. If you do not
   * specify a $filter clause including a startTime or endTime these filters default to the start and end
   * times of the last aggregation interval currently available; that is, only the last aggregation
   * interval is returned.
   * @param options The options parameters.
   */
  public listUsageMetrics(
    options?: PoolListUsageMetricsOptionalParams
  ): PagedAsyncIterableIterator<PoolUsageMetrics> {
    const iter = this.listUsageMetricsPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listUsageMetricsPagingPage(options);
      }
    };
  }

  private async *listUsageMetricsPagingPage(
    options?: PoolListUsageMetricsOptionalParams
  ): AsyncIterableIterator<PoolUsageMetrics[]> {
    let result = await this._listUsageMetrics(options);
    yield result.value || [];
    let continuationToken = result.odataNextLink;
    while (continuationToken) {
      result = await this._listUsageMetricsNext(continuationToken, options);
      continuationToken = result.odataNextLink;
      yield result.value || [];
    }
  }

  private async *listUsageMetricsPagingAll(
    options?: PoolListUsageMetricsOptionalParams
  ): AsyncIterableIterator<PoolUsageMetrics> {
    for await (const page of this.listUsageMetricsPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Lists all of the Pools in the specified Account.
   * @param options The options parameters.
   */
  public list(
    options?: PoolListOptionalParams
  ): PagedAsyncIterableIterator<CloudPool> {
    const iter = this.listPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listPagingPage(options);
      }
    };
  }

  private async *listPagingPage(
    options?: PoolListOptionalParams
  ): AsyncIterableIterator<CloudPool[]> {
    let result = await this._list(options);
    yield result.value || [];
    let continuationToken = result.odataNextLink;
    while (continuationToken) {
      result = await this._listNext(continuationToken, options);
      continuationToken = result.odataNextLink;
      yield result.value || [];
    }
  }

  private async *listPagingAll(
    options?: PoolListOptionalParams
  ): AsyncIterableIterator<CloudPool> {
    for await (const page of this.listPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * If you do not specify a $filter clause including a poolId, the response includes all Pools that
   * existed in the Account in the time range of the returned aggregation intervals. If you do not
   * specify a $filter clause including a startTime or endTime these filters default to the start and end
   * times of the last aggregation interval currently available; that is, only the last aggregation
   * interval is returned.
   * @param options The options parameters.
   */
  private _listUsageMetrics(
    options?: PoolListUsageMetricsOptionalParams
  ): Promise<PoolListUsageMetricsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listUsageMetricsOperationSpec
    ) as Promise<PoolListUsageMetricsResponse>;
  }

  /**
   * Statistics are aggregated across all Pools that have ever existed in the Account, from Account
   * creation to the last update time of the statistics. The statistics may not be immediately available.
   * The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes.
   * @param options The options parameters.
   */
  getAllLifetimeStatistics(
    options?: PoolGetAllLifetimeStatisticsOptionalParams
  ): Promise<PoolGetAllLifetimeStatisticsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getAllLifetimeStatisticsOperationSpec
    ) as Promise<PoolGetAllLifetimeStatisticsResponse>;
  }

  /**
   * When naming Pools, avoid including sensitive information such as user names or secret project names.
   * This information may appear in telemetry logs accessible to Microsoft Support engineers.
   * @param pool The Pool to be added.
   * @param options The options parameters.
   */
  add(
    pool: PoolAddParameter,
    options?: PoolAddOptionalParams
  ): Promise<PoolAddResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      pool,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      addOperationSpec
    ) as Promise<PoolAddResponse>;
  }

  /**
   * Lists all of the Pools in the specified Account.
   * @param options The options parameters.
   */
  private _list(options?: PoolListOptionalParams): Promise<PoolListResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listOperationSpec
    ) as Promise<PoolListResponse>;
  }

  /**
   * When you request that a Pool be deleted, the following actions occur: the Pool state is set to
   * deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing
   * the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and
   * requeued (as if a resize Pool operation had been requested with the default requeue option);
   * finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun
   * these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new
   * Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to
   * shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on
   * a Pool in the deleting state, it will fail with HTTP status code 409 with error code
   * PoolBeingDeleted.
   * @param poolId The ID of the Pool to delete.
   * @param options The options parameters.
   */
  delete(
    poolId: string,
    options?: PoolDeleteOptionalParams
  ): Promise<PoolDeleteResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      deleteOperationSpec
    ) as Promise<PoolDeleteResponse>;
  }

  /**
   * Gets basic properties of a Pool.
   * @param poolId The ID of the Pool to get.
   * @param options The options parameters.
   */
  exists(
    poolId: string,
    options?: PoolExistsOptionalParams
  ): Promise<PoolExistsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      existsOperationSpec
    ) as Promise<PoolExistsResponse>;
  }

  /**
   * Gets information about the specified Pool.
   * @param poolId The ID of the Pool to get.
   * @param options The options parameters.
   */
  get(
    poolId: string,
    options?: PoolGetOptionalParams
  ): Promise<PoolGetResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getOperationSpec
    ) as Promise<PoolGetResponse>;
  }

  /**
   * This only replaces the Pool properties specified in the request. For example, if the Pool has a
   * StartTask associated with it, and a request does not specify a StartTask element, then the Pool
   * keeps the existing StartTask.
   * @param poolId The ID of the Pool to update.
   * @param poolPatchParameter The parameters for the request.
   * @param options The options parameters.
   */
  patch(
    poolId: string,
    poolPatchParameter: PoolPatchParameter,
    options?: PoolPatchOptionalParams
  ): Promise<PoolPatchResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      poolPatchParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      patchOperationSpec
    ) as Promise<PoolPatchResponse>;
  }

  /**
   * Disables automatic scaling for a Pool.
   * @param poolId The ID of the Pool on which to disable automatic scaling.
   * @param options The options parameters.
   */
  disableAutoScale(
    poolId: string,
    options?: PoolDisableAutoScaleOptionalParams
  ): Promise<PoolDisableAutoScaleResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      disableAutoScaleOperationSpec
    ) as Promise<PoolDisableAutoScaleResponse>;
  }

  /**
   * You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If
   * automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as
   * part of the request. If automatic scaling of the Pool is already enabled, you may specify a new
   * autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more
   * than once every 30 seconds.
   * @param poolId The ID of the Pool on which to enable automatic scaling.
   * @param poolEnableAutoScaleParameter The parameters for the request.
   * @param options The options parameters.
   */
  enableAutoScale(
    poolId: string,
    poolEnableAutoScaleParameter: PoolEnableAutoScaleParameter,
    options?: PoolEnableAutoScaleOptionalParams
  ): Promise<PoolEnableAutoScaleResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      poolEnableAutoScaleParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      enableAutoScaleOperationSpec
    ) as Promise<PoolEnableAutoScaleResponse>;
  }

  /**
   * This API is primarily for validating an autoscale formula, as it simply returns the result without
   * applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a
   * formula.
   * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
   * @param poolEvaluateAutoScaleParameter The parameters for the request.
   * @param options The options parameters.
   */
  evaluateAutoScale(
    poolId: string,
    poolEvaluateAutoScaleParameter: PoolEvaluateAutoScaleParameter,
    options?: PoolEvaluateAutoScaleOptionalParams
  ): Promise<PoolEvaluateAutoScaleResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      poolEvaluateAutoScaleParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      evaluateAutoScaleOperationSpec
    ) as Promise<PoolEvaluateAutoScaleResponse>;
  }

  /**
   * You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the
   * request fails with status code 409. When you resize a Pool, the Pool's allocation state changes from
   * steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try
   * to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch
   * service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove
   * Compute Nodes API instead.
   * @param poolId The ID of the Pool to resize.
   * @param poolResizeParameter The parameters for the request.
   * @param options The options parameters.
   */
  resize(
    poolId: string,
    poolResizeParameter: PoolResizeParameter,
    options?: PoolResizeOptionalParams
  ): Promise<PoolResizeResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      poolResizeParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      resizeOperationSpec
    ) as Promise<PoolResizeResponse>;
  }

  /**
   * This does not restore the Pool to its previous state before the resize operation: it only stops any
   * further changes being made, and the Pool maintains its current state. After stopping, the Pool
   * stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the
   * stop operation, the Pool allocation state changes first to stopping and then to steady. A resize
   * operation need not be an explicit resize Pool request; this API can also be used to halt the initial
   * sizing of the Pool when it is created.
   * @param poolId The ID of the Pool whose resizing you want to stop.
   * @param options The options parameters.
   */
  stopResize(
    poolId: string,
    options?: PoolStopResizeOptionalParams
  ): Promise<PoolStopResizeResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      stopResizeOperationSpec
    ) as Promise<PoolStopResizeResponse>;
  }

  /**
   * This fully replaces all the updatable properties of the Pool. For example, if the Pool has a
   * StartTask associated with it and if StartTask is not specified with this request, then the Batch
   * service will remove the existing StartTask.
   * @param poolId The ID of the Pool to update.
   * @param poolUpdatePropertiesParameter The parameters for the request.
   * @param options The options parameters.
   */
  updateProperties(
    poolId: string,
    poolUpdatePropertiesParameter: PoolUpdatePropertiesParameter,
    options?: PoolUpdatePropertiesOptionalParams
  ): Promise<PoolUpdatePropertiesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      poolUpdatePropertiesParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      updatePropertiesOperationSpec
    ) as Promise<PoolUpdatePropertiesResponse>;
  }

  /**
   * This operation can only run when the allocation state of the Pool is steady. When this operation
   * runs, the allocation state changes from steady to resizing.
   * @param poolId The ID of the Pool from which you want to remove Compute Nodes.
   * @param nodeRemoveParameter The parameters for the request.
   * @param options The options parameters.
   */
  removeNodes(
    poolId: string,
    nodeRemoveParameter: NodeRemoveParameter,
    options?: PoolRemoveNodesOptionalParams
  ): Promise<PoolRemoveNodesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeRemoveParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      removeNodesOperationSpec
    ) as Promise<PoolRemoveNodesResponse>;
  }

  /**
   * ListUsageMetricsNext
   * @param nextLink The nextLink from the previous successful call to the ListUsageMetrics method.
   * @param options The options parameters.
   */
  private _listUsageMetricsNext(
    nextLink: string,
    options?: PoolListUsageMetricsNextOptionalParams
  ): Promise<PoolListUsageMetricsNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listUsageMetricsNextOperationSpec
    ) as Promise<PoolListUsageMetricsNextResponse>;
  }

  /**
   * ListNext
   * @param nextLink The nextLink from the previous successful call to the List method.
   * @param options The options parameters.
   */
  private _listNext(
    nextLink: string,
    options?: PoolListNextOptionalParams
  ): Promise<PoolListNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listNextOperationSpec
    ) as Promise<PoolListNextResponse>;
  }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const listUsageMetricsOperationSpec: coreHttp.OperationSpec = {
  path: "/poolusagemetrics",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.PoolListUsageMetricsResult,
      headersMapper: Mappers.PoolListUsageMetricsHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.startTime,
    Parameters.endTime,
    Parameters.filter,
    Parameters.maxResults1,
    Parameters.timeout2
  ],
  urlParameters: [Parameters.batchUrl],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId2,
    Parameters.returnClientRequestId2,
    Parameters.ocpDate2
  ],
  serializer
};
const getAllLifetimeStatisticsOperationSpec: coreHttp.OperationSpec = {
  path: "/lifetimepoolstats",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.PoolStatistics,
      headersMapper: Mappers.PoolGetAllLifetimeStatisticsHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout3],
  urlParameters: [Parameters.batchUrl],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId3,
    Parameters.returnClientRequestId3,
    Parameters.ocpDate3
  ],
  serializer
};
const addOperationSpec: coreHttp.OperationSpec = {
  path: "/pools",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.PoolAddHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.pool,
  queryParameters: [Parameters.apiVersion, Parameters.timeout4],
  urlParameters: [Parameters.batchUrl],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId4,
    Parameters.returnClientRequestId4,
    Parameters.ocpDate4
  ],
  mediaType: "json",
  serializer
};
const listOperationSpec: coreHttp.OperationSpec = {
  path: "/pools",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudPoolListResult,
      headersMapper: Mappers.PoolListHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter1,
    Parameters.select,
    Parameters.expand,
    Parameters.maxResults2,
    Parameters.timeout5
  ],
  urlParameters: [Parameters.batchUrl],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId5,
    Parameters.returnClientRequestId5,
    Parameters.ocpDate5
  ],
  serializer
};
const deleteOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: Mappers.PoolDeleteHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout6],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId6,
    Parameters.returnClientRequestId6,
    Parameters.ocpDate6,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince
  ],
  serializer
};
const existsOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}",
  httpMethod: "HEAD",
  responses: {
    200: {
      headersMapper: Mappers.PoolExistsHeaders
    },
    404: {},
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout7],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId7,
    Parameters.returnClientRequestId7,
    Parameters.ocpDate7,
    Parameters.ifMatch1,
    Parameters.ifNoneMatch1,
    Parameters.ifModifiedSince1,
    Parameters.ifUnmodifiedSince1
  ],
  serializer
};
const getOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudPool,
      headersMapper: Mappers.PoolGetHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.select1,
    Parameters.expand1,
    Parameters.timeout8
  ],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId8,
    Parameters.returnClientRequestId8,
    Parameters.ocpDate8,
    Parameters.ifMatch2,
    Parameters.ifNoneMatch2,
    Parameters.ifModifiedSince2,
    Parameters.ifUnmodifiedSince2
  ],
  serializer
};
const patchOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      headersMapper: Mappers.PoolPatchHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.poolPatchParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout9],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId9,
    Parameters.returnClientRequestId9,
    Parameters.ocpDate9,
    Parameters.ifMatch3,
    Parameters.ifNoneMatch3,
    Parameters.ifModifiedSince3,
    Parameters.ifUnmodifiedSince3
  ],
  mediaType: "json",
  serializer
};
const disableAutoScaleOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/disableautoscale",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.PoolDisableAutoScaleHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout10],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId10,
    Parameters.returnClientRequestId10,
    Parameters.ocpDate10
  ],
  serializer
};
const enableAutoScaleOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/enableautoscale",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.PoolEnableAutoScaleHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.poolEnableAutoScaleParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout11],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId11,
    Parameters.returnClientRequestId11,
    Parameters.ocpDate11,
    Parameters.ifMatch4,
    Parameters.ifNoneMatch4,
    Parameters.ifModifiedSince4,
    Parameters.ifUnmodifiedSince4
  ],
  mediaType: "json",
  serializer
};
const evaluateAutoScaleOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/evaluateautoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.AutoScaleRun,
      headersMapper: Mappers.PoolEvaluateAutoScaleHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.poolEvaluateAutoScaleParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout12],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId12,
    Parameters.returnClientRequestId12,
    Parameters.ocpDate12
  ],
  mediaType: "json",
  serializer
};
const resizeOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/resize",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: Mappers.PoolResizeHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.poolResizeParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout13],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId13,
    Parameters.returnClientRequestId13,
    Parameters.ocpDate13,
    Parameters.ifMatch5,
    Parameters.ifNoneMatch5,
    Parameters.ifModifiedSince5,
    Parameters.ifUnmodifiedSince5
  ],
  mediaType: "json",
  serializer
};
const stopResizeOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/stopresize",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: Mappers.PoolStopResizeHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout14],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId14,
    Parameters.returnClientRequestId14,
    Parameters.ocpDate14,
    Parameters.ifMatch6,
    Parameters.ifNoneMatch6,
    Parameters.ifModifiedSince6,
    Parameters.ifUnmodifiedSince6
  ],
  serializer
};
const updatePropertiesOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/updateproperties",
  httpMethod: "POST",
  responses: {
    204: {
      headersMapper: Mappers.PoolUpdatePropertiesHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.poolUpdatePropertiesParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout15],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId15,
    Parameters.returnClientRequestId15,
    Parameters.ocpDate15
  ],
  mediaType: "json",
  serializer
};
const removeNodesOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/removenodes",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: Mappers.PoolRemoveNodesHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.nodeRemoveParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout16],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId16,
    Parameters.returnClientRequestId16,
    Parameters.ocpDate16,
    Parameters.ifMatch7,
    Parameters.ifNoneMatch7,
    Parameters.ifModifiedSince7,
    Parameters.ifUnmodifiedSince7
  ],
  mediaType: "json",
  serializer
};
const listUsageMetricsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.PoolListUsageMetricsResult,
      headersMapper: Mappers.PoolListUsageMetricsNextHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.startTime,
    Parameters.endTime,
    Parameters.filter,
    Parameters.maxResults1,
    Parameters.timeout2
  ],
  urlParameters: [Parameters.batchUrl, Parameters.nextLink],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId2,
    Parameters.returnClientRequestId2,
    Parameters.ocpDate2
  ],
  serializer
};
const listNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudPoolListResult,
      headersMapper: Mappers.PoolListNextHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter1,
    Parameters.select,
    Parameters.expand,
    Parameters.maxResults2,
    Parameters.timeout5
  ],
  urlParameters: [Parameters.batchUrl, Parameters.nextLink],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId5,
    Parameters.returnClientRequestId5,
    Parameters.ocpDate5
  ],
  serializer
};
